package Problems.Chapter15_Generics.t_SelfBoundedTypes;

/**
 * @author SashaKhyzhun on 3/16/17. Page 567.
 * Необычные рекурсивны обобщения.
 *
 * Чтобы понять, что обозначает самоограничиваемый тип, для начала рассмотрим
 * упрощенную версию идиомы, в которой нет самоограничения. Прямое наследование
 * от обобщенного параметра невозможно. Тем не менее наследование можно применить
 * к классу, который использует обобщенный параметр в своем определении.
 * Другими словами, следующий фрагмент возможен:
 */

class GenericTypes<T> {}

public class CuriouslyRecurringGeneric extends GenericTypes<CuriouslyRecurringGeneric> {}


/**
 * Происходящее можно назвать «необычным рекурсивным обобщением (curiously recurring generics, СКО)
 * по названию паттерна «Необычный рекурсивный шаблон' для С++, описанного Джимом Коплином.
 * Под "необычной рекурсией" имеется в виду то, что класс несколько необычно появляется в своем базовом классе.
 * Чтобы понять, что это значит, попробуйте произнести вслух: "Я создаю новый класс, производный от
 * обобщенного типа, который получает имя моего класса как параметр".
 *
 * Что может сделать обобщенный базовый тип при получении имени производного класса?
 * Основной смысл обобщений в Java проявляется в передаче аргументов и возвращаемых типов,
 * так что он может создать базовый класс, использующий производный тип в типах своих аргументов
 * и возвращемого значения.
 *
 * Также производный тип может использоваться для типов полей,
 * несмотря на то что они будут стерты до Object.
 * Следующий обобщенный класс выражает эту мысль:
 */