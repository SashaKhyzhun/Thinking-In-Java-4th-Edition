
1) Очередность завершения должна быть обратной порядку инициализации
   в том случаи, если объекты зависят друг от друга


2) переопределенный метод производного класса может вернуть тип, производный от
   типа, возвращаемого методом базового класса. ("ковариантрости возвращаемых типов")


3) Кострукторы и полиморфзм дают не тот результат, который можно было бы ожидать.
   если вызывать метод в конструкторе, а этот метод есть в базовом и производном классе, то
   будет вызван метод который находиться в производном классе о_О (PolyConstructors.java);


4) Прямое обращение к полю разрешается во время компиляции. если будет одинаковое поле в
   базовом и производном классе, то возьмется с базового (extends ofc стоит), а вот метод
   возвращаемый значение какого-то хуя возьмет с производного класса. (FieldsAndStaticMethods.class)


5) Статические методы не поддерживают полиморфного поведения. то есть статие похуй на твое
   восходящее преобразование. одинаковый метод будет вызван с супер класса (FieldsAndStaticMethods2.class)


6) Полиморфирм позволяет нам динамически измененять поведения объекта
   с помощью композиции (паттерн проектирования "Состояние").


7) Проблема "переопределения" закрытых методов. закрытый (private) метод
   автоматически является неизменным (final), а заодно и скрытым от
   производного класса

8)