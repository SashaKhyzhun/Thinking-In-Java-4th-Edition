* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Класса / интерфейс        *                          Описание                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Set (интерфейст           * Каждый элемент, добавляемый в множесто Set, должен быть уникальным; *
*                           * в противном случае дубликат не добавляется. Все объекты помещаемые  *
*                           * в Set, должны определять метод equals() для выполнения сравнения.   *
*                           * Интерфейс Set полностью идентичен интерфейсу Collection. Множество  *
*                           * Set не гарантирует того, что хранимые в нем элементы будут          *
*                           * располагатся в определенном порядке.                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* HashSet"                  * Для реализаций Set, у который первостепенное значение имеет быстрый *
*                           * поиск. Хранимые объекты должны определять метод hashCode()          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* TreeSet                   * Упорядоченное множество, реализованное на основе дерева. Из него    *
*                           * можно извлекать упорядоченную последовательность элементов.         *
*                           * Элементы также должны реализовать интерфейс Comparable              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* LinkedHashSet             * Обладает аналогичной HashSet скоростью поиска, а также своими       *
*                           * силами (используя связанный поиск) запоминает порядок добавления    *
*                           * элементов (порядок вставки). Таким образом, при переборе элементов  *
*                           * этого множества они следуют в порядке вставки. Элементы такоже      *
*                           * должны определять hashCode()                                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* Звездочка рядом с HashSet указывает, что при отсутствии других ограничений
* следует выбирать именно этот вариант, потому что он оптимизирован по скорости.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Класс / интерфейс *                               Описание                                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* HashMap"          * Релизация карты на основе хеш-таблицы (используйте весто устаревшего    *
*                   * класса Hashtable). Поиск и вставка пар занимает небольше постоянное     *
*                   * время. Производительность можно настроить, указав в конструкторах       *
*                   * особые значения для емкости и коэффициента загрузки                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* LinkedHashMap     * Похожа на HashMap, однако при переборе выдает пары в порядке их         *
*                   * добавления, или согласно принциу LRU ("наименее используемые идут       *
*                   * первыми", least-recently-used). Лишь немногом медленнее HashMap, за     *
*                   * исключением процесса перечисления элементов, где она быстрее за счет    *
*                   * внутреннего связанного спискаа, отвечающего за хранение порядка         *
*                   * добавления элементов                                                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* TreeMap           * Реализаци карты на базе красно-черного дерева. При просмотре ключей или *
*                   * пар видно, что они соблюдают определенный порядок (который определяется *
*                   * интерфейсами Comparable или Comparator). Область применения карты       *
*                   * TreeMap - выдача результатов в отсортированном виде. Карта ThreeMap -   *
*                   * единственная карта с методом subMap(), который позволяет выделять из    *
*                   * карты некоторую ее часть                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* WeakHashMap       * Карта, состоящая из "слабых" ключей, которые не препятствуют            *
*                   * освобождению объектов, на которые ссылается карта; разработана для      *
*                   * решения определенного класса задач. Если за пределами карты ссылок      *
*                   * на ключ нет, он может быть удален уборщиком мусора                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* ConcurrentHashMap * Потоково-безопасная версия Map, не используюзая сигхронизационную       *
*                   * блокировку                                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* IdentityHashMap   * Хеш-таблица, искользующая для сравнения ключей оператор == вместо       *
*                   * equals(). Применяется в особых случаях, не для рядовых целей            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *