1) Чтобы определить коллекцию ArrayList для хранения объектов Apple, следует использовать
   запись ArrayList<Apple> вместо простого именни ArrayList. В угловые скобки заключаются
   параметры-типы (их может быть несколько). Теперь компилятор не позволяет поместить в
   ArrayList<Apple> любой другой объект; таким образом, разработчик узнает об ошибке не во
   время выполнения, а во время компиляции. (ApplesAndOrangesWithGenerics.java)

2) Библиотека контейнеров Java решает вопрос "хранения ваших объектов", рассмотривая его как
   совокупность двух различных концепций, выраженных основными интерфейсами библиотеки:

   Коллекция (Collection): последовательность отдельных элементов, формируемая по некоторым правилам.
   +--------------------------------------------------------------------------------------------+
   | Интерфейс List  (список)   хранит элементы в определенной последовательности               |
   +--------------------------------------------------------------------------------------------+
   |      \_____ ArrayList      Базовый контейнер с превосходной скоростью произвольного        |
   |                            доступа к эдементам, но относительно медленными  операциями     |
   |                            вставки и удаления элементов в середине.                        |
   +--------------------------------------------------------------------------------------------+
   |      \_____ LinkedList     Связанный список с оптимальными последовательным доступом и     |
   |                            низкозатратными операциями вставки и удаления в середине списка.|
   |                            Операции произвольного доступа LinkedList выполняет относительно|
   |                            медленно, но обладает более широкой функциональностью           |
   +--------------------------------------------------------------------------------------------+
   | Интерфейс Queue (очередь)  позволяет вставлять объекты с одного "конца" контейнера         |
   |                            и извлекать их с другого                                        |
   +--------------------------------------------------------------------------------------------+
   | Интерфейс Map   (карты)    в каждой ячейке хранятся два объекта: ключ и связанное с ним    |
   |                            значение. Набор пар объектов "Key-Value", с возможностью выборки|
   |                            значения по ключу. Контейнер ArrayList позволяет получить объект|
   |                            по числу, так что он в каком-то смысле связывает числа с        |
   |                            объектоми. Карта позволяет получить объект по другому объекту.  |
   |                            Также часто встречается термин ассоциативный массив (потому что |
   |                            объекты ассоциируются с другими объектами) и словарь (потому что|
   |                            объект-значение ищется по объекту-ключу, по аналогии с поиском  |
   |                            определения по слову).                                          |
   +--------------------------------------------------------------------------------------------+
   | Интерфейс Set  (множество) нельзя хранить повторяющиеся элементы.                          |
   +--------------------------------------------------------------------------------------------+
   |      \_____ HashSet        хранит элементы с применением сложного алгорима (см. главу 17), |
   |                            но это обеспечивает самую быструю  выборку элементов, но        |
   |                            порядок выглядит бессмысленно (самая быстрая).                  |
   +--------------------------------------------------------------------------------------------+
   |      \_____ TreeSet        хранит объекты упорядоченными по возрастанию (быстрая).         |
   +--------------------------------------------------------------------------------------------+
   |      \_____ LinkedHashSet  хранит элементы в порядке их добавления (быстрая).              |
   +--------------------------------------------------------------------------------------------+



3) Конструктор Collection может получить другой объект Collection, который используется для инициа-
   лизации, так что вы можете использовать Arrays.asList() для получения входных данных конструктора.
   Однако метод Collections.addAll() аботает намного быстрее, а решение с созданием Collection без
   элементов и последующим вызовом Collections.addAll() очень просто реализуется и поэтому считается
   предпочтительным.

4) Паттерн проектирования Итератор (iterator).
   Интератором называется объект, обеспечивающий перемещение по последовательности объектов с выбором
   каждого объекта этой последовательности; при этом программисту-клиенту не надо знать или заботиться
   о лежащем в ее основе структуре. Вдобавок, итератор обычно является так называемым "легковесным"
   (light-weight) объектом: его создание не должно занимать много ресурсов. Из-за этого для итераторов
   часто устанавливаются ограничения, которые на первый взгляд кажутся странными; например, в Java
   Iterator поддерживает перемещение не только в одном направленни. С итератором можно выполнять
   следующие операции:
   а) Запросить у Collection итератор посредством метода с именем iterator().
      Этот итератор готов вернуть начальный элемент последовательности
   б) Получить сделующий элемент последовательности вызовом метода next().
   в) Проверить, есть ли еще объекты в последовательности (метода hasNext()).
   г) Удалять из последовательности последний элемент, возвращенный итератором, методом remove().

5) ListIterator - интерфейс представляет собой более мощную разновидность Iterator, которая
                работает только с классами List. Хотя Iterator может перемещаться только вперед,
                итератор ListIterator является двусторонним. (.hasNext() и .hasPrevious()).
                Метод listIterator() возвращает объект ListIterator, указывающий в начало List,
                а вызов listIterator(n) создает объект listIterator, изначально установленный в
                позицию списка с индексом n.

6) LinkedList - Класс LinkedList, как и ArrayList, реализует базовый интерфейс List, но при этом
                выполняет некоторые операции (вставка и удаление в средине списка) более эффективно,
                чем ArrayList. И наоборот, с операциями произвольного доступа он работает менее
                эффективно. В LinkedList также добавляются методы, которые позволяют использовать
                его как стек, очередь или двустороннюю очередь (дек).