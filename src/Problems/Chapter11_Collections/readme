1) Чтобы определить коллекцию ArrayList для хранения объектов Apple, следует использовать
   запись ArrayList<Apple> вместо простого именни ArrayList. В угловые скобки заключаются
   параметры-типы (их может быть несколько). Теперь компилятор не позволяет поместить в
   ArrayList<Apple> любой другой объект; таким образом, разработчик узнает об ошибке не во
   время выполнения, а во время компиляции. (ApplesAndOrangesWithGenerics.java)

2) Библиотека контейнеров Java решает вопрос "хранения ваших объектов", рассмотривая его как
   совокупность двух различных концепций, выраженных основными интерфейсами библиотеки:

   Коллекция (Collection): последовательность отдельных элементов, формируемая по некоторым правилам.
   +--------------------------------------------------------------------------------------------+
   | Интерфейс List  (список)   хранит элементы в определенной последовательности               |
   +--------------------------------------------------------------------------------------------+
   | Интерфейс Queue (очередь)  позволяет вставлять объекты с одного "конца" контейнера         |
   |                            и извлекать их с другого                                        |
   +--------------------------------------------------------------------------------------------+
   | Интерфейс Map   (карты)    в каждой ячейке хранятся два объекта: ключ и связанное с ним    |
   |                            значение. Набор пар объектов "Key-Value", с возможностью выборки|
   |                            значения по ключу. Контейнер ArrayList позволяет получить объект|
   |                            по числу, так что он в каком-то смысле связывает числа с        |
   |                            объектоми. Карта позволяет получить объект по другому объекту.  |
   |                            Также часто встречается термин ассоциативный массив (потому что |
   |                            объекты ассоциируются с другими объектами) и словарь (потому что|
   |                            объект-значение ищется по объекту-ключу, по аналогии с поиском  |
   |                            определения по слову).                                          |
   +--------------------------------------------------------------------------------------------+
   | Интерфейс Set  (множество) нельзя хранить повторяющиеся элементы.                          |
   +--------------------------------------------------------------------------------------------+
   | HashSet, TreeSet, LinkedHashSet - Относятся к Set и по разному хранят свое содержание      |
   +--------------------------------------------------------------------------------------------+
   |                    HashSet: хранит элементы с применением сложного алгорима (см. главу 17),|
   |                             но это обеспечивает самую быструю  выборку элементов, но       |
   |                             порядок выглядит бессмысленно (самая быстрая).                 |
   +--------------------------------------------------------------------------------------------+
   |                    TreeSet: хранит объекты упорядоченными по возрастанию (быстрая).        |
   +--------------------------------------------------------------------------------------------+
   |              LinkedHashSet: хранит элементы в порядке их добавления (быстрая).             |
   +--------------------------------------------------------------------------------------------+

   Существуют две основные разновидности List:
      - Базовый контейнер ArrayList с превосходной скоростью произвольного доступа к эдементам,
        но относительно медленными операциями вставки и удаления элементов в середине.
      - Связанный список LinkedList с оптимальными последовательным доступом и низкозатратными
        операциями вставки и удаления в середине списка. Операции произвольного доступа LinkedList
        выполняет относительно медленно, но обладает более широкой функциональностью, чем ArrayList.

3) Конструктор Collection может получить другой объект Collection, который используется для инициа-
   лизации, так что вы можете использовать Arrays.asList() для получения входных данных конструктора.
   Однако метод Collections.addAll() аботает намного быстрее, а решение с созданием Collection без
   элементов и последующим вызовом Collections.addAll() очень просто реализуется и поэтому считается
   предпочтительным.

4) Паттерн проектирования Итератор (iterator).
   Интератором называется объект, обеспечивающий перемещение по последовательности объектов с выбором
   каждого объекта этой последовательности; при этом программисту-клиенту не надо знать или заботиться
   о лежащем в ее основе структуре. Вдобавок, итератор обычно является так называемым "легковесным"
   (light-weight) объектом: его создание не должно занимать много ресурсов. Из-за этого для итераторов
   часто устанавливаются ограничения, которые на первый взгляд кажутся странными; например, в Java
   Iterator поддерживает перемещение не только в одном направленни. С итератором можно выполнять
   следующие операции:
   а) Запросить у Collection итератор посредством метода с именем iterator().
      Этот итератор готов вернуть начальный элемент последовательности
   б) Получить сделующий элемент последовательности вызовом метода next().
   в) Проверить, есть ли еще объекты в последовательности (метода hasNext()).
   г) Удалять из последовательности последний элемент, возвращенный итератором, методом remove().