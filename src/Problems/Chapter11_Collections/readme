1) Чтобы определить коллекцию ArrayList для хранения объектов Apple, следует использовать
   запись ArrayList<Apple> вместо простого именни ArrayList. В угловые скобки заключаются
   параметры-типы (их может быть несколько). Теперь компилятор не позволяет поместить в
   ArrayList<Apple> любой другой объект; таким образом, разработчик узнает об ошибке не во
   время выполнения, а во время компиляции. (ApplesAndOrangesWithGenerics.java)

2) Библиотека контейнеров Java решает вопрос "хранения ваших объектов", рассмотривая его как
   совокупность двух различных концепций, выраженных основными интерфейсами библиотеки:

   Коллекция (Collection): последовательность отдельных элементов, формируемая по некоторым правилам.
   +------------------------------------------------------------------------------------------------------------------+
   | Интерфейс List  (список)    хранит элементы в определенной последовательности                                    |
   +------------------------------------------------------------------------------------------------------------------+
   | Интерфейс Queue (очередь)   позволяет вставлять объекты с одного "конца" контейнера и извлекать их с другого     |
   +------------------------------------------------------------------------------------------------------------------+
   | Интерфейс Map   (карты)     в каждой ячейке хранятся два объекта: ключ и связанное с ним значение.               |
   |                             Набор пар объектов "Key-Value", с возможностью выборки значения по ключу. Контейнер  |
   |                             ArrayList позволяет получить объект по числу, так что он в каком-то смысле связывает |
   |                             числа с объектоми. Карта позволяет получить объект по другому объекту. Также часто   |
   |                             встречается термин ассоциативный массив (потому что объекты ассоциируются с другими  |
   |                             объектами) и словарь (потому что объект-значение ищется по объекту-ключу, по         |
   |                             аналогии с поиском определения по слову).                                            |
   +------------------------------------------------------------------------------------------------------------------+
   | Интерфейс Set   (множество) нельзя хранить повторяющиеся элементы.                                               |
   +------------------------------------------------------------------------------------------------------------------+
   | HashSet, TreeSet, LinkedHashSet - Относятся к разновидностям Set и по разному хранят свое содержание.            |
   +------------------------------------------------------------------------------------------------------------------|
   |                    HashSet: хранит элементы с применением сложного алгорима (см. главу 17), но это обеспечивает  |
   |                             самую быструю  выборку элементов, но порядок выглядит бессмысленно (самая быстрая).  |
   +------------------------------------------------------------------------------------------------------------------|
   |                    TreeSet: хранит объекты упорядоченными по возрастанию (быстрая).                              |
   +------------------------------------------------------------------------------------------------------------------|
   |              LinkedHashSet: хранит элементы в порядке их добавления (быстрая).                                   |
   +------------------------------------------------------------------------------------------------------------------+

   Существуют две основные разновидности List:
      - Базовый контейнер ArrayList с превосходной скоростью произвольного доступа к эдементам,
        но относительно медленными операциями вставки и удаления элементов в середине.
      - Связанный список LinkedList с оптимальными последовательным доступом и низкозатратными
        операциями вставки и удаления в середине списка. Операции произвольного доступа LinkedList
        выполняет относительно медленно, но обладает более широкой функциональностью, чем ArrayList.

3) Конструктор Collection может получить другой объект Collection, который используется для инициа-
   лизации, так что вы можете использовать Arrays.asList() для получения входных данных конструктора.
   Однако метод Collections.addAll() аботает намного быстрее, а решение с созданием Collection без
   элементов и последующим вызовом Collections.addAll() очень просто реализуется и поэтому считается
   предпочтительным.

4)