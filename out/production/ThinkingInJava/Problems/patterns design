Паттерны проектирования:

Декоратор (Decoration) - использует иерархию объектов для динамического и прозрачного добавления обязанностей в
                         отдельные объекты. Он определяет, что все объекты, являющиеся <обертками> для вашего
                         исходного объекта, обладают единым базовым интерфейсом. Имеется декорируемый объект, а вы
                         наращиваете его функциональность посредством добавления «оберток». Это делает использование
                         декораторов прозрачным - имеется общий набор сообщений, которые могут отправляться объекту
                         независимо от того, был он декорирован или нет. Декорирующий класс может добавлять методы,
                         но, его возможности ограниченны.


Состояние (англ. State) — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения
                         программы объект должен менять своё поведение в зависимости от своего состояния.
                         здесь круто описано:
                                   https://refactoring.guru/ru/design-patterns/state
                                   http://cpp-reference.ru/patterns/behavioral-patterns/state/

Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов,
                         инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать
                         алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять
                         выбранный алгоритм независимо от объектов-клиентов, которые его используют.
                         здесь круто описано:
                                    https://refactoring.guru/ru/design-patterns/strategy
                         разница между "состоянием" и "стратегией" - http://ow.ly/9ys930aEHjq

Фильтр (англ. Filter) -  Шаблон фильтра или шаблон Критерий - это шаблон проектирования, который позволяет
                         разработчикам фильтровать набор объектов с использованием разных критериев и цепочки их
                         разделять путем логических операций. Этот тип дизайна приходит вместе.
                         детально здесь: https://www.tutorialspoint.com/design_pattern/filter_pattern



Адаптер (англ. Adapter) - Паттерн Adapter, представляющий собой программную обертку над существующими классами,
                         преобразует их интерфейсы к виду, пригодному для последующего использования.
                         Суть паттерна: обеспечивает совместную работу классов с несовместимыми интерфейсами.
                         v2: Написание кода для предоставления нужного интерфейса по имеющемуся интерфейсу.



Фабричный метод (англ. Factory Method) - это паттерн создания объектов (creational pattern). Данный шаблон
                         проектирования предоставляет интерфейс для создания экземпляров некоторого класса. В момент
                         создания наследники могут определить, какой класс инстанциировать.
                         Иными словами, Фабрика делегирует создание объектов наследникам родительского класса.
                         Это позволяет использовать в коде программы не специфические классы, а манипулировать
                         абстрактными объектами на более высоком уровне.


Итератор (англ. Iterator) - это поведенческий шаблон проектирования, который позволяет пройтись по всем элементам
                         некоторого составного объекта. Одним из важных условий при реализации паттерная является то,
                         что итератор должен гарантировать нераскрытие внутреннего устройства объекта.
                         В Java итераторы очень активно используются в Collection Framework. Для этих целей создан
                         специальный interface с одноименным названием java.util.Iterator. Интерфейс содержит
                         следующие методы:
                         - hasNext() - возвращает буелове значение в зависимости от того,
                                       есть ли еще элементы в коллекции.
                         - next()    - возвращает следующий элемент в коллекции. В соответствии
                                       с API метод должен бросать NoSuchElementException если все
                                       элементы уже пройдены.
                         - remove()  - удаляет элемент, который был возвращен последним вызовом next.
                                       К этому методу есть некоторые вопросы :) - почему собственно он
                                       находится в интерфейсе, ведь не каждая коллекция позволяет удалять
                                       элементы, в конце концов есть read only коллекции. Именно поэтому
                                       начиная с Java 1.8 метод remove описан как default с такой реализацией
                                       по умолчанию:
                                       default void remove() {throw new UnsupportedOperationException("remove");}



Заместитель (ргоху) - является одним из основных паттернов проектирования. Он представляет собой объект, который
                         подставляется на место "настоящего" объекта для предоставления дополнительных или других
                         операций - обычно подразумевающих взаимодействие с «настоящим" объектом, поэтому заместитель
                         чаще всего выполняет функции посредника.


Фасад (англ. Facade) — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех
                         возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.


Легковес (англ. Flyweight) - применяется в тех случаях, когда обычное решение требует слишком большого количества
                               объектов или создание обычных объектов требует слишком больших затрат памяти. Паттерн
                               "Легковес" - выводит наружу часть состовляющих объекта, чтобы обращение к ним
                               производилось более эффективно через внешнюю таблицу (или посредством других вычислений
                               для экономии памяти). (ex. Chapter 17, c_Abstact, Countries.java).









